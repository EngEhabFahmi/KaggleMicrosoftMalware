import pandas as pd
import time
import numpy as np
from collections import Counter
from os import listdir

path_to_bytes_file = "/Users/reillydj/Documents/Kaggle/KaggleMicrosoftMalware/dataSample/0A32eTdBKayjCWhZqDOQ.bytes"
path_to_directory = "/Users/reillydj/Documents/Kaggle/KaggleMicrosoftMalware/dataSample"


def get_file_names_from_directory(path):

    """
    :param path: path to directory with .bytes and .asm files
    :return: list of (.byte, .asm) files in sorted order
    """
    full_list = filter(lambda x: ('.swp' not in x) and (x != '.DS_Store'), listdir(path))

    asms = sorted(filter(lambda y: ('.asm' in y), full_list))
    bytes = sorted(filter(lambda z: ('.bytes' in z), full_list))
    asm_byte_pairs = zip(bytes, asms)

    return asm_byte_pairs

def file_to_text(path):

    file_to_be_read = open(path)
    text = file_to_be_read.read()

    return text

def file_to_pandas(path):

    df = pd.read_table(path, sep=' ', header=None, engine='c')

    return df

def test_pandas_engines(path):
    """
        Tested the execution times of the C, Python, and None (?just Python?)
        engines in the pandas read_table function.

        Results:

        C engine average =  0.0973811073303
        Python engine average =  0.173460905313
        None engine average =  0.102247326374
    """
    times = []
    for i in range(1000):
        start_time = time.time()
        df = pd.read_table(path, header=None, engine='c')
        times.append(time.time() - start_time)
    print 'C engine average = ', np.mean(times)

    times = []
    for i in range(1000):
        start_time = time.time()
        df = pd.read_table(path, header=None, engine='python')
        times.append(time.time() - start_time)
    print 'Python engine average = ', np.mean(times)

    times = []
    for i in range(1000):
        start_time = time.time()
        df = pd.read_table(path, header=None, engine=None)
        times.append(time.time() - start_time)
    print 'None engine average = ', np.mean(times)

def dictionary_of_proportions(list_of_elements):

    """
    :param list_of_elements: list of elements
    :return: dictionary of (element, proportion) pairs
    """
    denominator = float(len(list_of_elements))
    counter = Counter(list_of_elements)
    dictionary = dict(map(lambda y: (y[0], y[1] / denominator), counter.items()))

    return dictionary

def sort_dictionary(dictionary):
    """
    Useful for creating (consistent) pandas data frames
    :param dictionary: Dictionary of (feature, value) pairs
    :return: list of (feature, value) pairs in sorted order of feature
    """
    return [(key, dictionary[key]) for key in sorted(dictionary.keys())]

def split_text(path):

    """
    :param path: path to .bytes file
    :return: returns list of each element, split by a space,
             after removing the first column of .bytes file
    """
    return filter(lambda x: len(x) < 5, file_to_text(path).split())

def collect_rows(list_of_file_names):

    """
    :param list_of_file_names: list of paths to each .bytes file
    :return: pandas data frame where each row corresponds to a .bytes file
    """
    rows = [dictionary_of_proportions(split_text(path)) for path in list_of_file_names]

    return pd.DataFrame(rows)

if __name__ == '__main__':

    file_names = get_file_names_from_directory(path_to_directory)

    hard_coded_paths = ["/Users/reillydj/Documents/Kaggle/KaggleMicrosoftMalware/dataSample/" + el[0] for el in file_names]

    df = collect_rows(hard_coded_paths)

    df.insert(0, 'virus', [el[0][:20] for el in file_names])

    print df.head()